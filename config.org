(#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes)
#+Title: Cadair's Emacs Config
#+Author: Stuart Mumford
#+Description: Based on the excellent Kickstart https://github.com/MiniApollo/kickstart.emacs
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes
#+Startup: Overview
#+Options: toc:2

* About

This is my Emacs config, I use it primarily for Python development and also Org mode (although not implemented yet).

I use evil mode, and like the spacemacs style of a ~SPC~ leader key.
The keybinds I have are a combination of ones I learned in spacemace, doom and various other editors I have used over the years!

This literate config is was started from the excellent [[https://github.com/MiniApollo/kickstart.emacs/][kickstart.emacs]].

* Table Of Contents :toc:
:PROPERTIES:
:VISIBILITY: all
:END:
- [[#about][About]]
- [[#important-to-load-first][Important to load first]]
  - [[#startup-performance][Startup Performance]]
  - [[#auto-tangle-configuration-file][Auto-tangle Configuration file]]
  - [[#use-package][Use Package]]
  - [[#evil-mode][Evil Mode]]
- [[#keybindings][Keybindings]]
- [[#good-defaults][Good Defaults]]
- [[#appearance][Appearance]]
  - [[#set-theme][Set Theme]]
  - [[#transparency][Transparency]]
  - [[#fonts][Fonts]]
  - [[#modeline][Modeline]]
- [[#helper-functions][Helper functions]]
  - [[#file-management][File management]]
- [[#development][Development]]
  - [[#projects][Projects]]
  - [[#language-server][Language Server]]
  - [[#reformatting][Reformatting]]
  - [[#yasnippet][Yasnippet]]
  - [[#language-modes][Language modes]]
  - [[#terminal][Terminal]]
  - [[#combobulate][Combobulate]]
- [[#other-packages][Other Packages]]
  - [[#nerd-icons][Nerd Icons]]
  - [[#git][Git]]
  - [[#corfu][Corfu]]
  - [[#cape][Cape]]
  - [[#orderless][Orderless]]
  - [[#vertico-and-marginalia][Vertico and Marginalia]]
  - [[#consult][Consult]]
  - [[#diminish][Diminish]]
  - [[#rainbow-delimiters][Rainbow Delimiters]]
  - [[#which-key][Which-Key]]
  - [[#treemacs][Treemacs]]
  - [[#ranger][Ranger]]
  - [[#dashboard][Dashboard]]
  - [[#browse-kill-ring][Browse Kill-Ring]]
  - [[#flyspell][Flyspell]]
- [[#config-split-into-other-files][Config Split into Other Files]]
  - [[#adding-the-lisp-directory-to-load-path][Adding the lisp directory to load-path]]
  - [[#org-mode][Org Mode]]
- [[#runtime-performance][Runtime Performance]]

* Important to load first
** Startup Performance
Make startup faster by reducing the frequency of garbage collection. This will be set back when startup finishes.
#+begin_src emacs-lisp
    ;; The default is 800 kilobytes. Measured in bytes.
    (setq gc-cons-threshold (* 50 1000 1000))
#+end_src
** Auto-tangle Configuration file
Auto-Tangle Org configuration file for better startup times.

*Remember*, if this code can't be loaded (errors before this code), the init.el file won't update on change!
To fix this, you need to find this file (C-x C-f), fix the error and press C-c C-v t to tangle it manually.

This snippet adds a hook to org-mode buffers so that start/org-babel-tangle-config gets executed each time such a buffer gets saved.
This function checks to see if the file being saved is the Emacs.org file you’re looking at right now, and if so,
automatically exports the configuration here to the associated output files.
#+begin_src emacs-lisp
    (defun start/org-babel-tangle-config ()
      "Automatically tangle our Emacs.org config file when we save it. Credit to Emacs From Scratch for this one!"
      (when (string-equal (file-name-directory (buffer-file-name))
                          (expand-file-name user-emacs-directory))
        ;; Dynamic scoping to the rescue
        (let ((org-confirm-babel-evaluate nil))
          (org-babel-tangle))))

    (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'start/org-babel-tangle-config)))
#+end_src
** Use Package
We use the default package manager package.el with use-package. Alternative package managers (straight.el, elpaca, etc.) are useful if you want to
install packages from git repositories, if you want a specific, not very popular package that is not available on elpa or melpa,
or you want UI (elpaca) and other things.

If you are interested in these other package managers, check out their git repositories or search for more package managers.
In my experience Package.el is not slow and gets the job done.

To update/upgrade packages, use the package-upgrade-all command.
Check out the use-package [[https://www.gnu.org/software/emacs/manual/use-package.html][documentation]] to see how to use it.
With Emacs 29 use-package is now built-in.
#+begin_src emacs-lisp
    (require 'use-package-ensure) ;; Load use-package-always-ensure
    (setq use-package-always-ensure t) ;; Always ensures that a package is installed
    (setq package-archives '(("melpa" . "https://melpa.org/packages/") ;; Sets default package repositories
                             ("org" . "https://orgmode.org/elpa/")
                             ("elpa" . "https://elpa.gnu.org/packages/")
                             ("nongnu" . "https://elpa.nongnu.org/nongnu/"))) ;; For Eat Terminal
#+end_src

*** Quelpa
#+begin_src emacs-lisp
;;(use-package quelpa)
;;(use-package quelpa-use-package)
#+end_src
*** Straight
#+begin_src emacs-lisp
;;    (defvar bootstrap-version)
;;    (let ((bootstrap-file
;;           (expand-file-name
;;            "straight/repos/straight.el/bootstrap.el"
;;            (or (bound-and-true-p straight-base-dir)
;;                user-emacs-directory)))
;;          (bootstrap-version 7))
;;      (unless (file-exists-p bootstrap-file)
;;        (with-current-buffer
;;            (url-retrieve-synchronously
;;             "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
;;             'silent 'inhibit-cookies)
;;          (goto-char (point-max))
;;          (eval-print-last-sexp)))
;;      (load bootstrap-file nil 'nomessage))
#+end_src
** Evil Mode
An extensible vi/vim layer for Emacs. Because…let’s face it. The Vim keybindings are just plain better.
Notes:
- You can toggle evil mode with C-z.
- To paste without copy (yank) select the text and use P (shift-p).
  #+begin_src emacs-lisp
    (use-package evil
      :init ;; Execute code Before a package is loaded
      (evil-mode)
      :config ;; Execute code After a package is loaded
      (evil-set-initial-state 'eat-mode 'insert) ;; Set initial state in eat terminal to insert mode
      :custom ;; Customization of package custom variables
      (evil-want-keybinding nil)    ;; Disable evil bindings in other modes (It's not consistent and not good)
      (evil-want-C-u-scroll t)      ;; Set C-u to scroll up
      (evil-want-C-i-jump nil)      ;; Disables C-i jump
      (evil-undo-system 'undo-redo) ;; C-r to redo
      (org-return-follows-link t)   ;; Sets RETURN key in org-mode to follow links
      ;; Unmap keys in 'evil-maps. If not done, org-return-follows-link will not work
      :bind (:map evil-motion-state-map
                  ("SPC" . nil)
                  ("RET" . nil)
                  ("TAB" . nil)))

    (use-package evil-collection
      :after evil
      :config
      ;; Setting where to use evil-collection
      (setq evil-collection-mode-list '(dired ibuffer magit forge corfu vertico consult dashboard))
      (evil-collection-init))
#+end_src

* Keybindings
A keybinding framework to set keybindings easily. Uses https://github.com/noctuid/general.el
#+begin_src emacs-lisp
  (use-package general
    :config
    (general-evil-setup)
    ;; Global keys
    (general-define-key
     :states '(normal visual motion emacs)
     "K" 'scroll-down-command
     "J" 'scroll-up-command
     )

    ;; Set up a local-leader used for language mode specific functionality
    (general-create-definer my-local-leader
      :prefix ","
      )

    ;; Add some eglot related things to , because my muscle memory demands it
    (my-local-leader
      :states '(normal visual)
      ;; If I only enable this in eglot-mode-map then setting major-mode specific binds override this one
      ;;:keymaps 'eglot-mode-map
      "g" '(:ignore t :wk "Eglot goto")
      "g d" '(xref-find-definitions :wk "Goto Definition")
      "g D" '(xref-find-definitions-other-window :wk "Goto Definition (other window)")
      "g r" '(xref-find-references :wk "Find references")
      "d" '('eldoc-doc-buffer :wk "Documentation")
      )

    ;; Set up 'SPC' as primary leader key
    (general-create-definer start/leader-keys
      :states '(normal insert visual motion emacs)
      :keymaps 'override
      :prefix "SPC"           ;; Set leader key
      :global-prefix "C-SPC") ;; Set global leader key

    (start/leader-keys
      "SPC" '(execute-extended-command :wk "M-x")
      "." '(find-file :wk "Find file")
      "TAB" '(evil-switch-to-windows-last-buffer :wk "Last buffer")
      "/" '(+vertico/project-search :wk "Search Project")
      )

    (start/leader-keys
      "a" '(:ignore t :wk "Applications")
      "a r" '(ranger :wk "Ranger")
      )

    (start/leader-keys
      "b" '(:ignore t :wk "Buffer Bookmarks")
      "b b" '(consult-buffer :wk "Switch buffer")
      "b c" '(clone-indirect-buffer :wk "Clone buffer")
      "b C" '(clone-indirect-buffer-other-window :wk "Clone buffer other window")
      "b d" '(kill-current-buffer :wk "Kill buffer")
      "b i" '(ibuffer :wk "Ibuffer")
      "b j" '(consult-bookmark :wk "Bookmark jump")
      "b l" '(evil-switch-to-windows-last-buffer :wk "Switch to last buffer")
      "b m" '(bookmark-set :wk "Set bookmark")
      "b M" '(bookmark-delete :wk "Delete bookmark")
      "b n" '(next-buffer :wk "Next buffer")
      "b N" '(evil-buffer-new :wk "New empty buffer")
      "b p" '(previous-buffer :wk "Previous buffer")
      "b r" '(revert-buffer :wk "Reload buffer")
      "b R" '(rename-buffer :wk "Rename buffer")
      "b s" '(basic-save-buffer :wk "Save buffer")
      "b S" '(scratch-buffer :wk "Scratch Buffer")
      "b -" '(view-echo-area-messages :wk "Messages Buffer")
      )

    (start/leader-keys
      "c" '(:ignore t :wk "Code")
      "c a"   '(eglot-code-actions :wk "Code actions")
      "c b"   '(eval-buffer :wk "Evaluate elisp in buffer")
      "c d"   '(eldoc-doc-buffer :wk "Documentation")
      "c e"   '(eglot-reconnect :wk "Eglot Reconnect")
      "c f"   '(eglot-format :wk "Eglot Format")
      "c g d" '(xref-find-definitions :wk "Goto Definition")
      "c g D" '(xref-find-definitions-other-window :wk "Goto Definition (other window)")
      "c g r" '(xref-find-references :wk "Find references")
      "c l"   '(comment-or-uncomment-region :wk "Toggle Comments")
      )

    (start/leader-keys
      "d" '(:ignore t :wk "Dired")
      "j v" '(dired :wk "Open dired")
      "d j" '(dired-jump :wk "Dired jump to current")
      )

    (start/leader-keys
      "e"   '(:ignore t :wk "Evals and Errors")
      "e l" '(consult-flymake :wk "Consult Flymake")
      "e r" '(eval-region :wk "Evaluate elisp in region")
      )

    (start/leader-keys
      "f" '(:ignore t :wk "Find / Files")
      "f c" '((lambda () (interactive) (find-file "~/.config/emacs/config.org")) :wk "Edit emacs config")
  	"f C" '(doom/copy-this-file :wk "Copy this file")
      "f f" '(find-file :wk "Find file")
      "f g" '(consult-ripgrep :wk "Ripgrep search in files")
      "f i" '(consult-imenu :wk "Imenu buffer locations")
      "f l" '(consult-line :wk "Find line")
  	"f L" '(locate :wk "Locate file")
      "f r" '(consult-recent-file :wk "Recent files")
  	"f R" '(doom/move-this-file :wk "Rename/Move file")
      "f s" '(save-buffer :wk "Save Buffer")
      "f S" '(write-file :wk "Save file as...")
      )

    (start/leader-keys
      "g" '(:ignore t :wk "Git")
  	"g s"   '(magit                              :wk "Magit")
  	"g R"   '(vc-revert                          :wk "Revert file")
  	"g y"   '(git-link-homepage                  :wk "Copy link to remote")
  	"g t"   '(git-timemachine-toggle             :wk "Git time machine")
  	"g /"   '(magit-dispatch                     :wk "Magit dispatch")
  	"g ."   '(magit-file-dispatch                :wk "Magit file dispatch")
  	"g '"   '(forge-dispatch                     :wk "Forge dispatch")
  	"g -"   '(blamer-mode                        :wk "Toggle blamer")
  	"g b"   '(magit-branch-checkout              :wk "Magit switch branch")
  	"g b"   '(magit-blame-addition               :wk "Magit blame")
  	"g g"   '(magit-status                       :wk "Magit status")
  	"g G"   '(magit-status-here                  :wk "Magit status here")
  	"g D"   '(magit-file-delete                  :wk "Magit file delete")
  	"g C"   '(magit-clone                        :wk "Magit clone")
  	"g F"   '(magit-fetch                        :wk "Magit fetch")
  	"g L"   '(git-link                           :wk "Link to selection")
  	"g S"   '(magit-stage-buffer-file            :wk "Git stage this file")
  	"g U"   '(magit-unstage-buffer-file          :wk "Git unstage this file")
  	"g f"   '(:ignore t :wk "find")
  	"g f f" '(magit-find-file                    :wk "Find file")
  	"g f g" '(magit-find-git-config-file         :wk "Find gitconfig file")
  	"g f c" '(magit-show-commit                  :wk "Find commit")
  	"g f i" '(forge-visit-issue                  :wk "Find issue")
  	"g f p" '(forge-visit-pullreq                :wk "Find pull request")
  	"g o"   '(:ignore t :wk "open in browser")
  	"g o r" '(forge-browse-remote                :wk "Browse remote")
  	"g o c" '(forge-browse-commit                :wk "Browse commit")
  	"g o i" '(forge-browse-issue                 :wk "Browse an issue")
  	"g o p" '(forge-browse-pullreq               :wk "Browse a pull request")
  	"g o I" '(forge-browse-issues                :wk "Browse issues")
  	"g o P" '(forge-browse-pullreqs              :wk "Browse pull requests")
  	"g l"   '(:ignore t :wk "list")
  	;;"g l g" '(+gist:list                         :wk "List gists")
  	"g l r" '(magit-list-repositories            :wk "List repositories")
  	"g l s" '(magit-list-submodules              :wk "List submodules")
  	"g l i" '(forge-list-issues                  :wk "List issues")
  	"g l p" '(forge-list-pullreqs                :wk "List pull requests")
  	"g l n" '(forge-list-notifications           :wk "List notifications")
  	"g c"   '(:ignore t :wk "create")
  	"g c r" '(magit-init                         :wk "Initialize repo")
  	"g c R" '(magit-clone                        :wk "Clone repo")
  	"g c c" '(magit-commit-create                :wk "Commit")
  	"g c f" '(magit-commit-fixup                 :wk "Fixup")
  	"g c b" '(magit-branch-and-checkout          :wk "Branch")
  	"g c i" '(forge-create-issue                 :wk "Issue")
      "g c p" '(forge-create-pullreq               :wk "Pull request")
      )

    ;; TODO: It would be nice if I could just rebind C-h to SPC h
    (start/leader-keys
      "h" '(:ignore t :wk "Help") ;; To get more help use C-h commands (describe variable, function, etc.)
      "h k" '(describe-key :wk "Describe Key")
      "h s" '(describe-symbol :wk "Describe Symbol")
      "h v" '(describe-variable :wk "Describe Variable")
      "h f" '(describe-function :wk "Describe Function")
      "h b" '(describe-bindings :wk "Describe Bindings")
      )

    (start/leader-keys
      "l" '(:ignore t :wk "Tabspaces")
      "l C" '(tabspaces-clear-buffers :wk "Clear all Buffers")
      "l b" '(tabspaces-switch-to-buffer :wk "Switch to Buffer")
      "l d" '(tabspaces-close-workspace :wk "Close Workspace")
      "l k" '(tabspaces-kill-buffers-close-workspace :wk "Kill Buffers and Close Workspace")
      "l o" '(tabspaces-open-or-create-project-and-workspace :wk "Open Project and Workspace")
      "l r" '(tabspaces-remove-current-buffer :wk "Remove current buffer")
      "l R" '(tabspaces-restore-session :wk "Restore previous session")
      "l l" '(tabspaces-switch-or-create-workspace :wk "Switch or Create Workspace")
      "l t" '(tabspaces-switch-buffer-and-tab :wk "Switch Buffer and tab")
      ;; General Tab Control
      "l TAB" '(tab-previous :wk "Previous Tab")
      "l L" '(tab-move :wk "Move Tab Right")
      "l H" '((lambda ()
                (tab-move -1))
              :wk "Move Tab Left")
      )

    (start/leader-keys
      "p" '(:ignore t :wk "Projects")
      "p t" '(treemacs :wk "Treemacs")
      ;; Copied from project.el
      "p !" '(project-shell-command :wk "Run command")
      "p &" '(project-async-shell-command :wk "Run command (async)")
      "p f" '(project-find-file :wk "Find file")
      "p F" '(project-or-external-find-file :wk "Find file in project or external roots")
      "p b" '(project-switch-to-buffer :wk "Switch to project buffer")
      "p s" '(project-shell :wk "Run shell in project")
      "p d" '(project-find-dir :wk "Find directory")
      "p D" '(project-dired :wk "Dired")
      "p v" '(project-vc-dir :wk "Run VC-Dir")
      "p c" '(project-compile :wk "Compile Project")
      "p e" '(project-eshell :wk "Run Shell")
      "p k" '(project-kill-buffers :wk "Kill all buffers")
      "p p" '(tabspaces-open-or-create-project-and-workspace :wk "Switch Tabspaces")
      "p P" '(project-switch-project :wk "Switch Project")
      "p g" '(project-find-regexp :wk "Find matches for regexp")
      "p G" '(project-or-external-find-regexp :wk "Find matches for regexp in project or external")
      "p r" '(project-query-replace-regexp :wk "Replace regexp")
      "p x" '(project-execute-extended-command :wk "Execute extended command")
      "p o" '(project-any-command :wk "Execute any command")
      )

    (start/leader-keys
      "q" '(:ignore t :wk "Quit / Session")
      "q q" '(save-buffers-kill-emacs :wk "Quit Emacs and Daemon")
      "q r" '((lambda () (interactive)
                (load-file "~/SyncBox/new.emacs.d/init.el"))
              :wk "Reload Emacs config")
      )

    (start/leader-keys
      "s" '(:ignore t :wk "Show / Spell")
      "s e" '(eat :wk "Eat terminal")
      "s k" '(browse-kill-ring :wk "Show kill-ring")
      "s c" '(flyspell-correct-word-before-point :wk "Correct word at point")
      "s s" '(flyspell-toggle :wk "Toggle flyspell")
      "s n" '(evil-next-flyspell-error :wk "Next spelling error")
      )

    (start/leader-keys
      "t" '(:ignore t :wk "Toggle")
      "t t" '(visual-line-mode :wk "Toggle truncated lines (wrap)")
      "t l" '(display-line-numbers-mode :wk "Toggle line numbers")
      )

    (start/leader-keys
      "w" '(:ignore t :wk "Windows and Workspaces")
      "w h" '(evil-window-left :wk "Window left")
      "w l" '(evil-window-right :wk "Window right")
      "w j" '(evil-window-down :wk "Window Down")
      "w k" '(evil-window-up :wk "Window Up")
      "w /" '(evil-window-vsplit :wk "Vertical Split")
      "w -" '(evil-window-split :wk "Vertical Split")
      "w d" '(evil-window-delete :wk "Close window")
      )
    )
#+end_src

* Good Defaults
#+begin_src emacs-lisp
    (use-package emacs
      :custom
      (menu-bar-mode nil)         ;; Disable the menu bar
      (scroll-bar-mode nil)       ;; Disable the scroll bar
      (tool-bar-mode nil)         ;; Disable the tool bar
      (inhibit-startup-screen t)  ;; Disable welcome screen

      (delete-selection-mode t)   ;; Select text and delete it by typing.
      (electric-indent-mode t)    ;; Turn off the weird indenting that Emacs does by default.
      (electric-pair-mode nil)    ;; Turns off automatic parens pairing
      (blink-cursor-mode nil)     ;; Don't blink cursor
      (global-auto-revert-mode t) ;; Automatically reload file and show changes if the file has changed

      ;;(dired-kill-when-opening-new-dired-buffer t) ;; Dired don't create new buffer
      ;;(recentf-mode t) ;; Enable recent file mode

      ;;(global-visual-line-mode t)           ;; Enable truncated lines
      ;;(display-line-numbers-type 'relative) ;; Relative line numbers
      (global-display-line-numbers-mode t)  ;; Display line numbers

      (mouse-wheel-progressive-speed nil) ;; Disable progressive speed when scrolling
      (scroll-conservatively 10) ;; Smooth scrolling
      ;;(scroll-margin 8)

      (tab-width 4)

      (make-backup-files nil) ;; Stop creating ~ backup files
      (auto-save-default nil) ;; Stop creating # auto save files
      :hook
      (prog-mode . (lambda () (hs-minor-mode t))) ;; Enable folding hide/show globally
      :config
      ;; Move customization variables to a separate file and load it, avoid filling up init.el with unnecessary variables
      (setq custom-file (locate-user-emacs-file "custom-vars.el"))
      (load custom-file 'noerror 'nomessage)
      :bind (
             ([escape] . keyboard-escape-quit) ;; Makes Escape quit prompts (Minibuffer Escape)
             )
      ;; Fix general.el leader key not working instantly in messages buffer with evil mode
      :ghook ('after-init-hook
              (lambda (&rest _)
                (when-let ((messages-buffer (get-buffer "*Messages*")))
                  (with-current-buffer messages-buffer
                    (evil-normalize-keymaps))))
              nil nil t)
      )
#+end_src

* Appearance
** Set Theme
Set gruvbox theme, if you want some themes try out doom-themes.
Use consult-theme to easily try out themes (*Epilepsy* Warning).
#+begin_src emacs-lisp
    (use-package gruvbox-theme
      :config
      (load-theme 'gruvbox-dark-medium t)) ;; We need to add t to trust this package
#+end_src

** Transparency
With Emacs version 29, true transparency has been added.
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(alpha-background . 90)) ;; For all new frames henceforth
#+end_src

** Fonts
*** Setting fonts
#+begin_src emacs-lisp
  (set-face-attribute 'default nil
                      :font "JetBrains Mono"
                      :height 120
                      :weight 'medium)
  ;; This sets the default font on all graphical frames created after restarting Emacs.
  ;; Does the same thing as 'set-face-attribute default' above, but emacsclient fonts
  ;; are not right unless I also add this method of setting the default font.

  (add-to-list 'default-frame-alist '(font . "JetBrains Mono")) ;; Set your favorite font
  (setq-default line-spacing 0.01)
#+end_src

*** Zooming In/Out
You can use the bindings C-+ C-- for zooming in/out. You can also use CTRL plus the mouse wheel for zooming in/out.
#+begin_src emacs-lisp
  (use-package emacs
    :bind
    ("C-+" . text-scale-increase)
    ("C--" . text-scale-decrease)
    ("<C-wheel-up>" . text-scale-increase)
    ("<C-wheel-down>" . text-scale-decrease))
#+end_src

** Modeline
Replace the default modeline with a prettier more useful.
#+begin_src emacs-lisp
  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom
    (doom-modeline-height 25)     ;; Sets modeline height
    (doom-modeline-bar-width 5)   ;; Sets right bar width
    )
#+end_src
* Helper functions
Many of these are lifted from doom.
** File management
#+begin_src emacs-lisp
  (defun doom-files--update-refs (&rest files)
    "Ensure FILES are updated in `recentf', `magit' and `save-place'."
    (let (toplevels)
  	(dolist (file files)
        (when (featurep 'vc)
  		(vc-file-clearprops file)
  		(when-let (buffer (get-file-buffer file))
            (with-current-buffer buffer
  			(vc-refresh-state))))
        (when (featurep 'magit)
  		(when-let (default-directory (magit-toplevel (file-name-directory file)))
            (cl-pushnew default-directory toplevels)))
        (unless (file-readable-p file)
  		(when (bound-and-true-p recentf-mode)
            (recentf-remove-if-non-kept file))))
      (dolist (default-directory toplevels)
        (magit-refresh))
  	(when (bound-and-true-p save-place-mode)
        (save-place-forget-unreadable-files))))

  (defun doom/copy-this-file (new-path &optional force-p)
    "Copy current buffer's file to NEW-PATH then open NEW-PATH.

  If FORCE-P, overwrite the destination file if it exists, without confirmation."
    (interactive
     (list (read-file-name "Copy file to: ")
           current-prefix-arg))
    (unless (and buffer-file-name (file-exists-p buffer-file-name))
      (user-error "Buffer is not visiting any file"))
    (let ((old-path (buffer-file-name (buffer-base-buffer)))
          (new-path (expand-file-name new-path)))
      (make-directory (file-name-directory new-path) 't)
      (copy-file old-path new-path (or force-p 1))
      (find-file new-path)
      (doom-files--update-refs old-path new-path)
      (message "File copied to %S" (abbreviate-file-name new-path))))

  (defun doom/move-this-file (new-path &optional force-p)
    "Move current buffer's file to NEW-PATH.

  If FORCE-P, overwrite the destination file if it exists, without confirmation."
    (interactive
     (list (read-file-name "Move file to: ")
           current-prefix-arg))
    (unless (and buffer-file-name (file-exists-p buffer-file-name))
      (user-error "Buffer is not visiting any file"))
    (let ((old-path (buffer-file-name (buffer-base-buffer)))
          (new-path (expand-file-name new-path)))
      (when (directory-name-p new-path)
        (setq new-path (concat new-path (file-name-nondirectory old-path))))
      (make-directory (file-name-directory new-path) 't)
      (rename-file old-path new-path (or force-p 1))
      (set-visited-file-name new-path t t)
      (doom-files--update-refs old-path new-path)
      (message "File moved to %S" (abbreviate-file-name new-path))))
#+end_src
* Development
** Projects
We are going to try and use tabspaces / project.el

First setup project.el
#+BEGIN_SRC emacs-lisp
    (use-package project
      :custom
      (project-switch-commands 'project-find-file)  ;; Always open find file after switching project
      )
#+END_SRC

Then tab-bar
#+BEGIN_SRC emacs-lisp
    (use-package tab-bar
      :hook (after-init . tab-bar-mode)
      )
  #+END_SRC

Then tabspaces
#+BEGIN_SRC emacs-lisp
    (use-package tabspaces
      :hook (after-init . tabspaces-mode)
      :custom
      (tabspaces-use-filtered-buffers-as-default t)
      (tabspaces-default-tab "Default")
      (tabspaces-remove-to-default t)
      (tabspaces-include-buffers '("*scratch*"))
      (tabspaces-initialize-project-with-todo nil)
      ;; sessions
      (tabspaces-session t)
      (tabspaces-session-auto-restore nil)
      (tab-bar-new-tab-choice "*scratch*")
      )

    ;; Filter Buffers for Consult-Buffer
    (with-eval-after-load 'consult
      ;; hide full buffer list (still available with "b" prefix)
      (consult-customize consult--source-buffer :hidden t :default nil)
      ;; set consult-workspace buffer list
      (defvar consult--source-workspace
        (list :name     "Workspace Buffers"
              :narrow   ?w
              :history  'buffer-name-history
              :category 'buffer
              :state    #'consult--buffer-state
              :default  t
              :items    (lambda () (consult--buffer-query
                                                                :predicate #'tabspaces--local-buffer-p
                                                                :sort 'visibility
                                                                :as #'buffer-name)))

        "Set workspace buffer list for consult-buffer.")
      (add-to-list 'consult-buffer-sources 'consult--source-workspace))
#+END_SRC
** Language Server
*** Eglot
Language Server Protocol Support for Emacs. The built-in is now Eglot (with emacs 29).

Eglot is fast and minimal, but requires manual setup for LSP servers (downloading).
For more [[https://www.gnu.org/software/emacs/manual/html_mono/eglot.html][information how to use.]] One alternative to Eglot is Lsp-mode, check out the [[https://github.com/MiniApollo/kickstart.emacs/wiki][project wiki]] page for more information.

Eglot is easy to set up, but the only difficult part is downloading and setting up the lsp servers.
After that just add a hook with eglot-ensure to automatically start eglot for a given file type. And you are done.

If you can use a package manager just install the lsp server and add a hook.
Use visual block to uncomment easily in Org documents (C-v).
#+begin_src emacs-lisp
  (defun get-python-env-root ()
    "Return the value of `python-shell-virtualenv-root` if defined, otherwise nil."
    ;; This should work for micromamba and venvs
    (if (bound-and-true-p python-shell-virtualenv-root)
        python-shell-virtualenv-root
      nil))

  (use-package eglot
    :ensure nil ;; Don't install eglot because it's now built-in
    :hook ((python-mode python-ts-mode nix-mode) . eglot-ensure)
    :custom
    (add-to-list 'eglot-server-programs '(nix-mode . ("nil")))
    (eglot-events-buffer-size 0) ;; No event buffers (Lsp server logs)
    (eglot-autoshutdown t);; Shutdown unused servers.
    (eglot-report-progress nil) ;; Disable lsp server logs (Don't show lsp messages at the bottom, java)

    ;; Dynamically load the workspace configuration so that we set jedi to use the active workspace
    (eglot-workspace-configuration
     (lambda (&rest args)
       (let ((venv-directory (get-python-env-root)))
         (message "Located venv: %s" venv-directory)
         `((:pylsp .
                   (:plugins
                                  (:jedi_completion (:fuzzy t)
                                                                        :jedi (:environment ,venv-directory)
                                                                        :pydocstyle (:enabled nil)
                                                                        :pycodestyle (:enabled nil)
                                                                        :mccabe (:enabled nil)
                                                                        :pyflakes (:enabled nil)
                                                                        :flake8 (:enabled nil)
                                                                        :black (:enabled nil))))))))
    )
#+end_src

#+BEGIN_SRC emacs-lisp
(defun restart-eglot ()
  (interactive)
  ;; Check if there's an active Eglot server
  (let ((current-server (eglot-current-server)))
    ;; If a server exists, prompt the user to continue
    (if current-server
        ;; Shut down the server if user confirms
        (eglot-shutdown current-server)))
  ;; Restart Eglot for the current buffer
  (eglot-ensure))
#+END_SRC
** TODO Reformatting
Would be nice to have ruff --fix and ruff-format, isort etc all available.
https://melpa.org/#/reformatter
** Yasnippet
A template system for Emacs. And yasnippet-snippets is a snippet collection package.
To use it write out the full keyword (or use autocompletion) and press Tab.
#+begin_src emacs-lisp
  (use-package yasnippet-snippets
    :hook (prog-mode . yas-minor-mode))
#+end_src

** Language modes
I am using tree-sitter, with the Language grammars installed by nixos.
Some of this borrowed from https://gist.github.com/habamax/290cda0e0cdc6118eb9a06121b9bc0d7

To manually install the grammar for a language run ~treesit-install-language-grammar~.

*** Python mode and packages

First, we map the tree-sitter mode to the non-treesitter mode so things hooked into ~python-mode~ also works in ~python-ts-mode~.

#+begin_src emacs-lisp
  (setq major-mode-remap-alist
        '((python-mode . python-ts-mode)))
#+end_src

I am using both micromamba and virtualenvwrapper-style virtual envs, so we enable packages for both of those:

#+begin_src emacs-lisp
  (use-package pyvenv
    :ensure t
    :hook (pyvenv-post-activate-hooks . restart-eglot)
    )

  (use-package micromamba
    :ensure t
    :hook (micromamba-postactivate-hook . restart-eglot)
    )
#+end_src

Enable the excellent pytest package, and setup an extra hook for [[https://github.com/astropy/pytest-remotedata][pytest-remotedata]].

#+begin_src emacs-lisp
  (use-package python-pytest
    :config
    (transient-append-suffix 'python-pytest-dispatch
        '(-2)
        ["Remote data"
         ("--rd" "Remote data" "--remote-data=any")]
        )
    )
#+end_src

Finally, setup the flymake-ruff package, currently my own fork of it where I am working on enabling different levels of errors.

#+begin_src emacs-lisp
  (use-package flymake-ruff
    :load-path "local-packages/flymake-ruff"
    :ensure t
    :hook (eglot-managed-mode . flymake-ruff-load)
    :custom
    (flymake-ruff-error-regex "SyntaxError")
    (flymake-ruff-warning-regex ".*")
    )
#+end_src

**** Custom Functions
:PROPERTIES:
:VISIBILITY: folded
:END:
Custom written functions for Python related stuff
#+begin_src emacs-lisp
    ;; Add to __all__
    (defsubst python-in-string/comment ()
      "Return non-nil if point is in a Python literal (a comment or string)."
      ;; We don't need to save the match data.
      (nth 8 (syntax-ppss)))

    (defun python-add-to-all ()
      "Take the symbol under the point and add it to the __all__ list, if it's not already there."
      (interactive)
      (save-excursion
        (let ((thing (thing-at-point 'symbol)))
          (if (progn (goto-char (point-min))
                     (let (found)
                       (while (and (not found)
                                   (re-search-forward (rx symbol-start "__all__" symbol-end
                                                          (0+ space) "=" (0+ space)
                                                          (syntax open-parenthesis))
                                                      nil t))
                         (setq found (not (python-in-string/comment))))
                       found))
              (when (not (looking-at (rx-to-string
                                      `(and (0+ (not (syntax close-parenthesis)))
                                            (syntax string-quote) ,thing (syntax string-quote)))))
                (insert (format "\'%s\', " thing)))
            (beginning-of-buffer)
            ;; Put before any import lines, or if none, the first class or
            ;; function.
            (when (re-search-forward (rx bol (or "import" "from") symbol-end) nil t)
              (re-search-forward (rx symbol-start (or "def" "class") symbol-end) nil t))
            (forward-line -1)
            (insert (format "\n__all__ = [\'%s\']\n\n" thing))))))

    (defun +python-executable-find (exe)
      "Resolve the path to the EXE executable.
        Tries to be aware of your active conda/pipenv/virtualenv environment, before
        falling back on searching your PATH."
      (if (file-name-absolute-p exe)
          (and (file-executable-p exe)
               exe)
        (let ((exe-root (format "bin/%s" exe)))
          (cond ((when python-shell-virtualenv-root
                   (let ((bin (expand-file-name exe-root python-shell-virtualenv-root)))
                     (if (file-exists-p bin) bin))))
                ((when (require 'conda nil t)
                   (let ((bin (expand-file-name (concat conda-env-current-name "/" exe-root)
                                                (conda-env-default-location))))
                     (if (file-executable-p bin) bin))))
                ((when-let (bin (projectile-locate-dominating-file default-directory exe-root))
                   (setq-local doom-modeline-python-executable (expand-file-name exe-root bin))))
                ((executable-find exe))))))

    (defun +python/open-repl ()
      "Open the Python REPL."
      (interactive)
      (require 'python)
      (unless python-shell-interpreter
        (user-error "`python-shell-interpreter' isn't set"))
      (pop-to-buffer
       (process-buffer
        (let ((dedicated (bound-and-true-p python-shell-dedicated)))
          (if-let* ((pipenv (+python-executable-find "pipenv"))
                    (pipenv-project (pipenv-project-p)))
              (let ((default-directory pipenv-project)
                    (python-shell-interpreter-args
                     (format "run %s %s"
                             python-shell-interpreter
                             python-shell-interpreter-args))
                    (python-shell-interpreter pipenv))
                (run-python nil dedicated t))
            (run-python nil dedicated t))))))

    (defun +python/open-ipython-repl ()
      "Open an IPython REPL."
      (interactive)
      (require 'python)
      (let ((python-shell-interpreter
             (or (+python-executable-find (car +python-ipython-command))
                 "ipython"))
            (python-shell-interpreter-args
             (string-join (cdr +python-ipython-command) " ")))
        (+python/open-repl)))

    (defvar +python-ipython-command '("ipython" "-i" "--simple-prompt" "--no-color-info")
      "Command to initialize the ipython REPL for `+python/open-ipython-repl'.")

    (defun cadair/run-restart-repl ()
      "Run a new python repl in a window which does not have focus."
      (interactive)
      (setq initial-buffer (current-buffer))
      (if (python-shell-get-buffer)
          (kill-buffer (python-shell-get-buffer)))
      (+python/open-ipython-repl)
      (evil-normal-state)
      (pop-to-buffer initial-buffer)
      )

    (defun cadair/run-in-repl (arg)
      "Run a python buffer in a new ipython repl"
      (interactive "P")
      (cadair/run-restart-repl)
      (run-at-time 0.5 nil 'python-shell-send-buffer)
      )

    (defun cadair/run-in-repl-switch (arg)
      "Run a python buffer in a new ipython repl"
      (interactive "P")
      (cadair/run-restart-repl)
      (run-at-time 0.5 nil 'python-shell-send-buffer)
      (run-at-time 1.0 nil (pop-to-buffer (python-shell-get-buffer)))
      )

    (defun cadair/python-execute-file (arg)
      "Execute a python script in a shell."
      (interactive "P")
      ;; set compile command to buffer-file-name
      ;; universal argument put compile buffer in comint mode
      (let ((universal-argument t)
            (compile-command (format "python %s"
                                     (shell-quote-argument (file-name-nondirectory buffer-file-name)))))
        (if arg
            (call-interactively 'compile)
          (compile compile-command t)
          (with-current-buffer (get-buffer "*compilation*")
            (inferior-python-mode)))))

#+end_src

**** Keybindings

A bunch of language specific key binds, using ~,~ as the leader key.

#+begin_src emacs-lisp
  (my-local-leader
    :states 'normal
    :keymaps 'python-ts-mode-map
    "t a" 'python-pytest
    "t f" 'python-pytest-file-dwim
    "t F" 'python-pytest-file
    "t t" 'python-pytest-run-def-or-class-at-point-dwim
    "t T" 'python-pytest-run-def-or-class-at-point
    "t r" 'python-pytest-repeat
    "t p" 'python-pytest-dispatch

    "c" 'cadair/python-execute-file
    "r" 'cadair/run-in-repl
    "R" 'cadair/run-in-repl-switch
    "a" 'python-add-to-all

    "m a" 'micromamba-activate
    "m d" 'micromamba-deactivate
    "v a" 'pyvenv-workon
    "v d" 'pyvenv-deactivate
    )
#+end_src

*** Org Mode
Org mode is one of the things that emacs is loved for.
Once you've used it for a bit, you'll understand why people love it. Even reading about it can be inspiring!
For example, this document is effectively the source code and descriptions bound into the one document,
much like the literate programming ideas that Donald Knuth made famous.
#+begin_src emacs-lisp
    (use-package org
      :ensure nil
      :custom
      (org-edit-src-content-indentation 2) ;; Set src block automatic indent to 4 instead of 2.

      :hook
      (org-mode . org-indent-mode) ;; Indent text
      ;; The following prevents <> from auto-pairing when electric-pair-mode is on.
      ;; Otherwise, org-tempo is broken when you try to <s TAB...
      ;;(org-mode . (lambda ()
      ;;              (setq-local electric-pair-inhibit-predicate
      ;;                          `(lambda (c)
      ;;                             (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))))
      )
#+end_src

**** Table of Contents
#+begin_src emacs-lisp
    (use-package toc-org
      :commands toc-org-enable
      :hook (org-mode . toc-org-mode))
#+end_src

**** Org Superstar
Prettify headings and plain lists in Org mode. Modern version of org-bullets.
#+begin_src emacs-lisp
    (use-package org-superstar
      :after org
      :hook (org-mode . org-superstar-mode))
#+end_src

**** Source Code Block Tag Expansion
Org-tempo is not a separate package but a module within org that can be enabled.
Org-tempo allows for '<s' followed by TAB to expand to a begin_src tag.
#+begin_src emacs-lisp
    (use-package org-tempo
      :ensure nil
      :after org)
#+end_src

*** nix
#+begin_src emacs-lisp
  (use-package nix-mode)
#+end_src

**** Keybindings

A bunch of language specific key binds, using ~,~ as the leader key.

#+begin_src emacs-lisp
  (my-local-leader
    :states 'normal
    :keymaps 'nix-mode-map
    "f" 'nix-flake
    )
#+end_src
*** TODO Rust
https://github.com/emacs-rustic/rustic

** Terminal
*** Eat
Eat(Emulate A Terminal) is a terminal emulator within Emacs.
It's more portable and less overhead for users over like vterm or eshell.
We setup eat with eshell, if you want to use bash, zsh etc., check out their git [[https://codeberg.org/akib/emacs-eat][repository]] how to do it.
#+begin_src emacs-lisp
    (use-package eat
      :hook ('eshell-load-hook #'eat-eshell-mode))
#+end_src
** TODO Combobulate
#+begin_src emacs-lisp
  (use-package combobulate
    :custom
    ;; You can customize Combobulate's key prefix here.
    ;; Note that you may have to restart Emacs for this to take effect!
    (combobulate-key-prefix "SPC o")
    :hook ((prog-mode . combobulate-mode))
    ;; Amend this to the directory where you keep Combobulate's source
    ;; code.
    :vc (:url "https://github.com/mickeynp/combobulate"
         :branch "main")
    )
#+end_src
* Other Packages
All the package setups that don't need much tweaking.
** Nerd Icons
For icons and more helpful UI.
This is an icon set that can be used with dired, ibuffer and other Emacs programs.

Don't forget to use nerd-icons-install-fonts.

We use Nerd icons because it has more, better icons and all-the-icons only supports GUI.
While nerd-icons supports both GUI and TUI.
#+begin_src emacs-lisp
    (use-package nerd-icons
      :if (display-graphic-p))

    (use-package nerd-icons-dired
      :hook (dired-mode . (lambda () (nerd-icons-dired-mode t))))

    (use-package nerd-icons-ibuffer
      :hook (ibuffer-mode . nerd-icons-ibuffer-mode))
#+end_src

** Git
*** Magit
Complete text-based user interface to Git.
#+begin_src emacs-lisp
  (use-package magit
    :commands magit-status)
  (use-package forge
    :after magit
  )
#+end_src

*** Diff-hl
Highlights uncommitted changes on the left side of the window (area also known as the "gutter"), allows you to jump between and revert them selectively.
#+begin_src emacs-lisp
    (use-package diff-hl
      :hook ((dired-mode         . diff-hl-dired-mode-unless-remote)
             (magit-pre-refresh  . diff-hl-magit-pre-refresh)
             (magit-post-refresh . diff-hl-magit-post-refresh))
      :init (global-diff-hl-mode))
#+end_src
*** git-link
Creates URLs to forges
#+begin_src emacs-lisp
  (use-package git-link
    :custom
    (git-link-use-commit t)
  )
#+end_src
*** git-timemachine
#+begin_src emacs-lisp
(use-package git-timemachine)
#+end_src
*** blamer
#+begin_src emacs-lisp
(use-package blamer)
#+end_src
*** TODO igist
https://github.com/KarimAziev/igist
** Corfu
Enhances in-buffer completion with a small completion popup.
Corfu is a small package, which relies on the Emacs completion facilities and concentrates on providing a polished completion.
For more configuration options check out their [[https://github.com/minad/corfu][git repository]].
Notes:
- To enter Orderless field separator, use M-SPC.
#+begin_src emacs-lisp
    (use-package corfu
      ;; Optional customizations
      :custom
      (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
      (corfu-auto t)                 ;; Enable auto completion
      (corfu-auto-prefix 2)          ;; Minimum length of prefix for auto completion.
      (corfu-popupinfo-mode t)       ;; Enable popup information
      (corfu-popupinfo-delay 0.5)    ;; Lower popupinfo delay to 0.5 seconds from 2 seconds
      (corfu-separator ?\s)          ;; Orderless field separator, Use M-SPC to enter separator
      ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
      ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
      ;; (corfu-preview-current nil)    ;; Disable current candidate preview
      ;; (corfu-preselect 'prompt)      ;; Preselect the prompt
      ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
      ;; (corfu-scroll-margin 5)        ;; Use scroll margin
      (completion-ignore-case t)
      ;; Enable indentation+completion using the TAB key.
      ;; `completion-at-point' is often bound to M-TAB.
      (tab-always-indent 'complete)
      (corfu-preview-current nil) ;; Don't insert completion without confirmation
      ;; Recommended: Enable Corfu globally.  This is recommended since Dabbrev can
      ;; be used globally (M-/).  See also the customization variable
      ;; `global-corfu-modes' to exclude certain modes.
      :init
      (global-corfu-mode))

    (use-package nerd-icons-corfu
      :after corfu
      :init (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src

** Cape
Provides Completion At Point Extensions which can be used in combination with Corfu, Company or the default completion UI.
Notes:
- The functions that are added later will be the first in the completion list.
- Take care when adding Capfs (Completion-at-point-functions) to the list since each of the Capfs adds a small runtime cost.
Read the [[https://github.com/minad/cape#configuration][configuration section]] in Cape's readme for more information.
#+begin_src emacs-lisp
    (use-package cape
      :after corfu
      :init
      ;; Add to the global default value of `completion-at-point-functions' which is
      ;; used by `completion-at-point'.  The order of the functions matters, the
      ;; first function returning a result wins.  Note that the list of buffer-local
      ;; completion functions takes precedence over the global list.
      ;; The functions that are added later will be the first in the list

      (add-to-list 'completion-at-point-functions #'cape-dabbrev) ;; Complete word from current buffers
      (add-to-list 'completion-at-point-functions #'cape-dict) ;; Dictionary completion
      (add-to-list 'completion-at-point-functions #'cape-file) ;; Path completion
      (add-to-list 'completion-at-point-functions #'cape-elisp-block) ;; Complete elisp in Org or Markdown mode
      (add-to-list 'completion-at-point-functions #'cape-keyword) ;; Keyword/Snipet completion

      ;;(add-to-list 'completion-at-point-functions #'cape-abbrev) ;; Complete abbreviation
      ;;(add-to-list 'completion-at-point-functions #'cape-history) ;; Complete from Eshell, Comint or minibuffer history
      ;;(add-to-list 'completion-at-point-functions #'cape-line) ;; Complete entire line from current buffer
      ;;(add-to-list 'completion-at-point-functions #'cape-elisp-symbol) ;; Complete Elisp symbol
      ;;(add-to-list 'completion-at-point-functions #'cape-tex) ;; Complete Unicode char from TeX command, e.g. \hbar
      ;;(add-to-list 'completion-at-point-functions #'cape-sgml) ;; Complete Unicode char from SGML entity, e.g., &alpha
      ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345) ;; Complete Unicode char using RFC 1345 mnemonics
      )
#+end_src
*** TODO See about setting some capf's only in certain modes
** TODO Orderless
Learn to use more fancy parts of orderless: https://github.com/oantolin/orderless?tab=readme-ov-file#component-matching-styles

Completion style that divides the pattern into space-separated components, and matches candidates that match all of the components in any order.
Recomended for packages like vertico, corfu.
#+begin_src emacs-lisp
    (use-package orderless
      :custom
      (completion-styles '(orderless basic))
      (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

** Vertico and Marginalia
- Vertico: Provides a performant and minimalistic vertical completion UI based on the default completion system.
- Savehist: Saves completion history.
- Marginalia: Adds extra metadata for completions in the margins (like descriptions).
- Nerd-icons-completion: Adds icons to completion candidates using the built in completion metadata functions.

We use this packages, because they use emacs native functions. Unlike Ivy or Helm.
One alternative is ivy and counsel, check out the [[https://github.com/MiniApollo/kickstart.emacs/wiki][project wiki]] for more information.
#+begin_src emacs-lisp
  (use-package vertico
    :init
    (vertico-mode))

  (use-package vertico-posframe
    :init
    (setq vertico-posframe-parameters   '((left-fringe  . 12)    ;; Fringes
                                                                                (right-fringe . 12)
                                                                                (undecorated  . nil))) ;; Rounded frame
    :config
    (vertico-posframe-mode 1)
    (setq vertico-posframe-width        120                      ;; Narrow frame
                vertico-posframe-height       25                       ;; Default height
                ;; Don't create posframe for these commands
                vertico-multiform-commands    '((consult-line    (:not posframe))
                                                                                (consult-ripgrep (:not posframe))))
    )

  (savehist-mode) ;; Enables save history mode

  (use-package marginalia
    :after vertico
    :init
    (marginalia-mode))

  (use-package nerd-icons-completion
    :after marginalia
    :config
    (nerd-icons-completion-mode)
    :hook
    ('marginalia-mode-hook . 'nerd-icons-completion-marginalia-setup))
#+end_src

*** Project wide text search from doomemacs

#+begin_src emacs-lisp
(cl-defun +vertico-file-search (&key query in all-files (recursive t) prompt args)
  "Conduct a file search using ripgrep.

:query STRING
  Determines the initial input to search for.
:in PATH
  Sets what directory to base the search out of. Defaults to the current project's root.
:recursive BOOL
  Whether or not to search files recursively from the base directory.
:args LIST
  Arguments to be appended to `consult-ripgrep-args'."
  (declare (indent defun))
  (unless (executable-find "rg")
    (user-error "Couldn't find ripgrep in your PATH"))
  (require 'consult)
  (setq deactivate-mark t)
  (let* ((project-root (or default-directory))
         (directory (or in project-root))
         (consult-ripgrep-args
          (concat "rg "
                  (if all-files "-uu ")
                  (unless recursive "--maxdepth 1 ")
                  "--null --line-buffered --color=never --max-columns=1000 "
                  "--path-separator /   --smart-case --no-heading "
                  "--with-filename --line-number --search-zip "
                  "--hidden -g !.git -g !.svn -g !.hg "
                  (mapconcat #'identity args " ")))
         (prompt (if (stringp prompt) (string-trim prompt) "Search"))
         (query)
         (consult-async-split-style consult-async-split-style)
         (consult-async-split-styles-alist consult-async-split-styles-alist))
    ;; Change the split style if the initial query contains the separator.
    (when query
      (cl-destructuring-bind (&key type separator initial _function)
          (consult--async-split-style)
        (pcase type
          (`separator
           (replace-regexp-in-string (regexp-quote (char-to-string separator))
                                     (concat "\\" (char-to-string separator))
                                     query t t))
          (`perl
           (when (string-match-p initial query)
             (setf (alist-get 'perlalt consult-async-split-styles-alist)
                   `(:initial ,(or (cl-loop for char in (list "%" "@" "!" "&" "/" ";")
                                            unless (string-match-p char query)
                                            return char)
                                   "%")
                     :type perl)
                   consult-async-split-style 'perlalt))))))
    (consult--grep prompt #'consult--ripgrep-make-builder directory query)))

(defun +vertico/project-search (&optional arg initial-query directory)
  "Performs a live project search from the project root using ripgrep.
If ARG (universal argument), include all files, even hidden or compressed ones,
in the search."
  (interactive "P")
  (+vertico-file-search :query initial-query :in directory :all-files arg))
#+end_src

** Consult
Provides search and navigation commands based on the Emacs completion function.
Check out their [[https://github.com/minad/consult][git repository]] for more awesome functions.
#+begin_src emacs-lisp
    (use-package consult
      ;; Enable automatic preview at point in the *Completions* buffer. This is
      ;; relevant when you use the default completion UI.
      :hook (completion-list-mode . consult-preview-at-point-mode)
      :init
      ;; Optionally configure the register formatting. This improves the register
      ;; preview for `consult-register', `consult-register-load',
      ;; `consult-register-store' and the Emacs built-ins.
      (setq register-preview-delay 0.5
            register-preview-function #'consult-register-format)

      ;; Optionally tweak the register preview window.
      ;; This adds thin lines, sorting and hides the mode line of the window.
      (advice-add #'register-preview :override #'consult-register-window)

      ;; Use Consult to select xref locations with preview
      (setq xref-show-xrefs-function #'consult-xref
            xref-show-definitions-function #'consult-xref)
      :config
      ;; Optionally configure preview. The default value
      ;; is 'any, such that any key triggers the preview.
      ;; (setq consult-preview-key 'any)
      ;; (setq consult-preview-key "M-.")
      ;; (setq consult-preview-key '("S-<down>" "S-<up>"))

      ;; For some commands and buffer sources it is useful to configure the
      ;; :preview-key on a per-command basis using the `consult-customize' macro.
      ;; (consult-customize
      ;; consult-theme :preview-key '(:debounce 0.2 any)
      ;; consult-ripgrep consult-git-grep consult-grep
      ;; consult-bookmark consult-recent-file consult-xref
      ;; consult--source-bookmark consult--source-file-register
      ;; consult--source-recent-file consult--source-project-recent-file
      ;; :preview-key "M-."
      ;; :preview-key '(:debounce 0.4 any))

      ;; By default `consult-project-function' uses `project-root' from project.el.
      ;; Optionally configure a different project root function.
       ;;;; 1. project.el (the default)
       ;; (setq consult-project-function #'consult--default-project--function)
       ;;;; 2. vc.el (vc-root-dir)
      ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
       ;;;; 3. locate-dominating-file
      ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
       ;;;; 4. projectile.el (projectile-project-root)
      ;; (autoload 'projectile-project-root "projectile")
      ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
       ;;;; 5. No project support
      ;; (setq consult-project-function nil)
      )
#+end_src
*** TODO Learn this!
** Diminish
This package implements hiding or abbreviation of the modeline displays (lighters) of minor-modes.
With this package installed, you can add ‘:diminish’ to any use-package block to hide that particular mode in the modeline.
#+begin_src emacs-lisp
    (use-package diminish)
#+end_src

** Rainbow Delimiters
Adds colors to brackets.
#+begin_src emacs-lisp
    (use-package rainbow-delimiters
      :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Which-Key
Which-key is a helper utility for keychords (which key to press).
#+begin_src emacs-lisp
    (use-package which-key
      :init
      (which-key-mode 1)
      :diminish
      :custom
      (which-key-side-window-location 'bottom)
      (which-key-sort-order #'which-key-key-order-alpha) ;; Same as default, except single characters are sorted alphabetically
      (which-key-sort-uppercase-first nil)
      (which-key-add-column-padding 1) ;; Number of spaces to add to the left of each column
      (which-key-min-display-lines 6)  ;; Increase the minimum lines to display, because the default is only 1
      (which-key-idle-delay 0.8)       ;; Set the time delay (in seconds) for the which-key popup to appear
      (which-key-max-description-length 25)
      (which-key-allow-imprecise-window-fit nil)) ;; Fixes which-key window slipping out in Emacs Daemon
#+end_src

** Treemacs
#+begin_src emacs-lisp
    (use-package treemacs
      :ensure t
      :defer t
      :init (treemacs-project-follow-mode)
      )
    (use-package treemacs-evil
      :after (treemacs evil)
      :ensure t
      )
    (use-package treemacs-magit
      :after (treemacs magit)
      :ensure t
      )
  #+end_src
** Ranger

#+begin_src emacs-lisp
    (use-package ranger)
#+END_SRC

** Dashboard
#+begin_src emacs-lisp
  ;; use-package with package.el:
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    :custom
    (dashboard-display-icons-p t)     ; display icons on both GUI and terminal
    (dashboard-icon-type 'nerd-icons) ; use `nerd-icons' package
    (dashboard-center-content t)
    (dashboard-vertically-center-content t)
    (dashboard-items '(
                       (projects  . 5)
                                         (recents   . 5)
                       (agenda    . 5)
                                         ))
    )

#+end_src

** Browse Kill-Ring
#+begin_src emacs-lisp
  (use-package browse-kill-ring)
#+end_src

** Flyspell
I want to have spell checking, because I am not good at the spelling, so I auto-enable flyspell.
This auto-detect is taken from here: https://www.emacswiki.org/emacs/FlySpell#h5o-3
#+begin_src emacs-lisp
  (defun flyspell-on-for-buffer-type ()
    "Enable Flyspell appropriately for the major mode of the current buffer.  Uses `flyspell-prog-mode' for modes derived from `prog-mode', so only strings and comments get checked.  All other buffers get `flyspell-mode' to check all text.  If flyspell is already enabled, does nothing."
    (interactive)
    (if (not (symbol-value flyspell-mode)) ; if not already on
          (progn
                (if (derived-mode-p 'prog-mode)
                        (progn
                          (message "Flyspell on (code)")
                          (flyspell-prog-mode))
                  ;; else
                  (progn
                        (message "Flyspell on (text)")
                        (flyspell-mode 1)))
                ;; I tried putting (flyspell-buffer) here but it didn't seem to work
                )))

  (defun flyspell-toggle ()
    "Turn Flyspell on if it is off, or off if it is on.  When turning on, it uses `flyspell-on-for-buffer-type' so code-vs-text is handled appropriately."
    (interactive)
    (if (symbol-value flyspell-mode)
          (progn ; flyspell is on, turn it off
                (message "Flyspell off")
                (flyspell-mode -1))
                                                                                ; else - flyspell is off, turn it on
      (flyspell-on-for-buffer-type)))

  (add-hook 'find-file-hook 'flyspell-on-for-buffer-type)
#+end_src
* Config Split into Other Files
** Adding the lisp directory to load-path
Add the ~lisp~ directory to the path.
#+begin_src emacs-lisp
  (add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
#+end_src

** Org Mode

#+begin_src emacs-lisp
;;  (require 'cadair-org-mode)
#+end_src

* Runtime Performance
Dial the GC threshold back down so that garbage collection happens more frequently but in less time.
We also increase Read Process Output Max so emacs can read more data.
#+begin_src emacs-lisp
    ;; Make gc pauses faster by decreasing the threshold.
    (setq gc-cons-threshold (* 2 1000 1000))
    ;; Increase the amount of data which Emacs reads from the process
    (setq read-process-output-max (* 1024 1024)) ;; 1mb
#+end_src
